package kernel

import (
	"goshort/types"
	errors2 "goshort/types/errors"
	"os"
	"os/signal"
	"sync"
	"sync/atomic"
	"syscall"
)

type Kernel struct {
	InputControllers    []types.InputControllerInterface
	UrlController       types.UrlControllerInterface
	Loggers             []types.LoggerInterface
	Middlewares         []types.MiddlewareInterface
	ExtraordinaryLogger types.LoggerInterface
	DefaultRedirectCode int
	nextOperationNumber uint64
	Stopped             bool
	wg                  sync.WaitGroup
}

type MiddlewareFunc func(url *types.Url) error

func (kernel *Kernel) Get(operationNumber uint64, key string) (types.Url, error) {
	return kernel.UrlController.Get(key)
}

func (kernel *Kernel) Post(operationNumber uint64, newUrl types.Url) (types.Url, error) {
	if newUrl.Code == 0 {
		newUrl.Code = 301
	}
	if newUrl.Key == "" {
		newUrl.Autogenerated = true
	}

	newUrl, err := kernel.applyMiddlewares(operationNumber, newUrl)
	if err != nil {
		return newUrl, err
	}

	if newUrl.Autogenerated && !kernel.UrlController.GenericKeySupport() {
		return newUrl, errors2.GenericKeysAreNotSupported
	}

	return kernel.UrlController.Post(newUrl)
}

func (kernel *Kernel) Patch(operationNumber uint64, patchUrl types.Url) error {
	return kernel.UrlController.Patch(patchUrl)
}

func (kernel *Kernel) Delete(operationNumber uint64, url_ types.Url) error {
	return kernel.UrlController.Delete(url_)
}

type SignalGotLog struct {
	Signal string
}

func (log *SignalGotLog) ToMap() map[string]interface{} {
	return map[string]interface{}{
		"name":   "Kernel.GotSignal",
		"type":   "log",
		"signal": log.Signal,
	}
}

func (kernel *Kernel) Run(blocking bool) error {
	_ = kernel.GetNextOperationNumber()
	kernel.wg.Add(len(kernel.Loggers) + len(kernel.InputControllers) + 1)

	// start loggers
	var erroredLoggers []struct {
		types.LoggerInterface
		error
	}
	for _, logger := range kernel.Loggers {
		if err := logger.Run(); err != nil {
			erroredLoggers = append(erroredLoggers, struct {
				types.LoggerInterface
				error
			}{logger, err})
		}
	}
	for _, erroredLogger := range erroredLoggers {
		err := erroredLogger.error
		kernel.Log(false, true, err)
		kernel.BadConnectionErrorManage(err, erroredLogger.LoggerInterface, kernel.loggerErrorsLoggingFunction)
	}

	// start url controller
	if err := kernel.UrlController.Run(); err != nil {
		kernel.Log(false, false, err)
		kernel.BadConnectionErrorManage(err, kernel.UrlController, kernel.standardControllerErrorsLoggingFunction)
	}

	// start input controllers
	for _, inputController := range kernel.InputControllers {
		if err := inputController.Run(); err != nil {
			kernel.Log(false, false, err)
			kernel.BadConnectionErrorManage(err, inputController, kernel.standardControllerErrorsLoggingFunction)
		}
	}

	if !blocking {
		return nil
	}

	signals := make(chan os.Signal, 1)
	done := make(chan bool, 1)

	signal.Notify(signals, syscall.SIGINT, syscall.SIGTERM)
	go func() {
		sig := <-signals
		kernel.SystemLog(&SignalGotLog{Signal: sig.String()})
		done <- true
	}()

	kernel.SystemLog(&errors2.GenericLog{Name: "Kernel.StartSignalWaiting", IsError: false})
	<-done
	kernel.SystemLog(&errors2.GenericLog{Name: "Kernel.Shutdown", IsError: false})
	kernel.Stop()

	return nil
}

func (kernel *Kernel) Stop() {
	kernel.Stopped = true
	for _, input := range kernel.InputControllers {
		input.Stop()
	}
	kernel.UrlController.Stop()
	for _, logger := range kernel.Loggers {
		logger.Stop()
	}

	kernel.wg.Wait()
}

func (kernel *Kernel) applyMiddlewares(operationNumber uint64, url types.Url) (types.Url, error) {
	for _, middleware := range kernel.Middlewares {
		err := middleware.Exec(&url)
		if err != nil {
			if middleware.BreakOnError() {
				return url, err
			} else {
				kernel.SystemLog(err)
			}
		}
	}
	return url, nil
}

func (kernel *Kernel) GetNextOperationNumber() uint64 {
	return atomic.AddUint64(&kernel.nextOperationNumber, 1)
}

func (kernel *Kernel) OperationDone() {
	kernel.wg.Done()
}
