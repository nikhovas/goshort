package goshort

import (
	"github.com/PuerkitoBio/purell"
	"github.com/gorilla/mux"
	"github.com/mediocregopher/radix/v3"
	"github.com/spf13/viper"
	"goshort/utils"
	"net/http"
)

func urlsPostHandler(w http.ResponseWriter, r *http.Request) {
	url_, err := CreateUrlFromHttpRequest(w, r)
	if err != nil {
		utils.ErrorToResponse(err, w)
		return
	}

	if url_.Code == 0 {
		url_.Code = 301
	}

	url_.Url, err = purell.NormalizeURLString(url_.Url,
		purell.FlagLowercaseScheme|purell.FlagLowercaseHost|purell.FlagUppercaseEscapes)
	if err != nil {
		utils.ErrorToResponse(&utils.SimpleResponse{Status: 500, Msg: "incorrect URL"}, w)
		return
	}

	if url_.Key == "" {
		url_.Autogenerated = true
		added := false
		for !added {
			var potentialKey string
			potentialKey, err = GetAutogenUrlFromRedis(AppObject.Pool, url_.Url)
			if err != nil {
				utils.ErrorToResponse(&utils.SimpleResponse{Status: http.StatusInternalServerError, Msg: "Redis error"}, w)
				return
			}

			if potentialKey != "" {
				var potentialUrl Url
				if potentialUrl, err = CreateUrlFromRedis(AppObject.Pool, potentialKey); err != nil {
					utils.ErrorToResponse(err, w)
					return
				}

				if potentialUrl.Url == url_.Url {
					url_ = potentialUrl
					added = true
				}
			} else {
				url_.Key = utils.GetNewUrlString(AppObject.Pool)

				if added, err = url_.CreateInRedis(AppObject.Pool); err != nil {
					utils.ErrorToResponse(err, w)
					return
				}
			}
		}
	} else {
		result, err := url_.CreateInRedis(AppObject.Pool)
		if err != nil {
			utils.ErrorToResponse(err, w)
			return
		} else if !result {
			utils.ErrorToResponse(&utils.SimpleResponse{Status: http.StatusConflict, Msg: "Value already exists"}, w)
			return
		}
	}

	url_.ToHttpResponse(w)
}

func urlsGetHandler(w http.ResponseWriter, _ *http.Request, url Url) {
	url.ToHttpResponse(w)
}

func urlsPatchRequest(w http.ResponseWriter, r *http.Request, url Url) {
	newUrl, err := CreateUrlFromHttpRequest(w, r)
	if err != nil {
		utils.ErrorToResponse(err, w)
		return
	}

	url.Url = newUrl.Url
	err = url.UpdateInRedis(AppObject.Pool)
	if err != nil {
		utils.ErrorToResponse(err, w)
		return
	}

	url.ToHttpResponse(w)
}

func urlsDeleteRequest(w http.ResponseWriter, _ *http.Request, key string) {
	err := AppObject.Pool.Do(radix.Cmd(nil, "DEL", key))
	if err != nil {
		utils.ErrorToResponse(err, w)
		return
	}
}

func checkTokenMiddleware(next func(w http.ResponseWriter, r *http.Request)) func(w http.ResponseWriter, r *http.Request) {
	return func(w http.ResponseWriter, r *http.Request) {
		correctToken := viper.GetString("token")
		if correctToken != "" {
			token := r.Header.Get("Authorization")
			if token == "" {
				utils.ErrorToResponse(&utils.SimpleResponse{Status: http.StatusUnauthorized, Msg: "Need auth credentials"}, w)
				return
			} else if "Bearer "+correctToken != token {
				utils.ErrorToResponse(&utils.SimpleResponse{Status: http.StatusUnauthorized, Msg: "Bad auth credentials"}, w)
				return
			}
		}
		next(w, r)
	}
}

func urlDetailsHandler(w http.ResponseWriter, r *http.Request) {
	url, err := CreateUrlFromRedis(AppObject.Pool, mux.Vars(r)["id"])
	if err != nil {
		utils.ErrorToResponse(err, w)
		return
	}

	if r.Method == http.MethodGet {
		urlsGetHandler(w, r, url)
	} else if r.Method == http.MethodPatch || r.Method == http.MethodPut {
		urlsPatchRequest(w, r, url)
	} else { // DELETE
		urlsDeleteRequest(w, r, url.Key)
	}
}

func RegisterUrlsHandlers(router *mux.Router) {
	router.HandleFunc("/urls/", checkTokenMiddleware(urlsPostHandler)).Methods(http.MethodPost)
	router.HandleFunc("/urls/{id}/", checkTokenMiddleware(urlDetailsHandler)).Methods(http.MethodGet,
		http.MethodPatch, http.MethodPut, http.MethodDelete)
}
