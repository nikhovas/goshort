package dbModules

import (
	"errors"
	"github.com/mediocregopher/radix/v3"
	"goshort/kernel"
	"goshort/kernel/utils"
	"goshort/types"
	kernelErrors "goshort/types/errors"
	"sync"
	"time"
)

type Redis struct {
	types.ModuleBase
	pool     *radix.Pool
	ip       string
	poolSize int
	name     string
	Kernel   *kernel.Kernel
}

func CreateRedis(kernel *kernel.Kernel) types.DatabaseInterface {
	return &Redis{Kernel: kernel}
}

func (controller *Redis) Init(config map[string]interface{}) error {
	if err := controller.ModuleBase.Init(config); err != nil {
		return err
	}
	controller.pool = nil
	controller.ip = config["ip"].(string)
	controller.poolSize = config["pool_size"].(int)
	return nil
}

func (controller *Redis) Connect() error {
	var err error
	controller.pool, err = radix.NewPool("tcp", controller.ip, controller.poolSize)
	return err
}

func (controller *Redis) Run(wg *sync.WaitGroup) error {
	wg.Done()
	err := controller.Connect()
	if err != nil {
		return err
	}
	controller.Kernel.SetModuleRunState(controller)
	return nil
}

func (controller *Redis) Stop() error {
	if controller.pool != nil {
		controller.Kernel.SetModuleStopState(controller)
		return controller.pool.Close()
	}
	return nil
}

func (controller *Redis) TryReconnect() error {
	return controller.Connect()
}

func (controller *Redis) Get(key string) (types.Url, error) {
	var preUrl string
	if err := controller.pool.Do(radix.Cmd(&preUrl, "GET", "url "+key)); err != nil {
		return types.Url{}, err
	}
	if preUrl == "" {
		return types.Url{}, kernelErrors.NotFoundError
	}

	urlData, err := types.FromString(preUrl)
	if err != nil {
		return types.Url{}, nil
	}
	urlData.Key = key

	return urlData, nil
}

func (controller *Redis) Post(newUrl types.Url) (types.Url, error) {
	var p string
	if newUrl.Autogenerated {
		added := false
		for !added {
			potentialKey, err := controller.GetPotentialKey(newUrl.Url)
			if err != nil && !errors.Is(err, kernelErrors.NotFoundError) {
				return types.Url{}, err
			}

			if err == nil { // key is found
				potentialUrl, err := controller.Get(potentialKey)
				if err != nil && !errors.Is(err, kernelErrors.NotFoundError) {
					return types.Url{}, err
				}
				if potentialUrl.Url == newUrl.Url {
					newUrl = potentialUrl
					added = true
				}
			} else { // key is free
				newUrl.Key, err = controller.GetNewUniqueKey()

				err = controller.pool.Do(radix.Cmd(&p, "SET", "url "+newUrl.Key, newUrl.ToString(), "NX"))
				// todo inspect
				if errors.Is(err, kernelErrors.ValueAlreadyExistsError) {
					added = false
				} else if err != nil {
					return types.Url{}, err
				} else {
					added = true
				}

				err = controller.pool.Do(radix.Cmd(nil, "SET", "autogen "+newUrl.Url, newUrl.Key))
				if err != nil {
					return types.Url{}, nil
				}
			}
			time.Sleep(time.Second)
		}
	} else {
		err := controller.pool.Do(radix.Cmd(&p, "SET", "url "+newUrl.Key, newUrl.ToString(), "NX"))
		if err != nil {
			return types.Url{}, err
		}
	}

	return newUrl, controller.pool.Do(radix.Cmd(nil, "SAVE"))
}

func (controller *Redis) Patch(patchUrl types.Url) error {
	if patchUrl.Autogenerated {
		p := radix.Pipeline(
			radix.Cmd(nil, "SET", "url "+patchUrl.Key, patchUrl.ToString()),
			radix.Cmd(nil, "SET", "autogen "+patchUrl.Url, patchUrl.Key),
		)

		if err := controller.pool.Do(p); err != nil {
			panic(err)
		}
	} else {
		err := controller.pool.Do(
			radix.Cmd(nil, "SET", "url "+patchUrl.Key, patchUrl.ToString()))
		if err != nil {
			return err
		}
	}

	return controller.pool.Do(radix.Cmd(nil, "SAVE"))
}

func (controller *Redis) Delete(key string) error {
	url_, err := controller.Get(key)
	if err != nil {
		return err
	}

	if url_.Autogenerated {
		p := radix.Pipeline(
			radix.Cmd(nil, "DEL", "url "+url_.Key, url_.ToString()),
			radix.Cmd(nil, "DEL", "autogen "+url_.Url, url_.Key),
		)

		if err := controller.pool.Do(p); err != nil {
			return err
		}
	} else {
		err := controller.pool.Do(
			radix.Cmd(nil, "DEL", "url "+url_.Key, url_.ToString()))
		if err != nil {
			return err
		}
	}
	return controller.pool.Do(radix.Cmd(nil, "SAVE"))
}

func (controller *Redis) GetPotentialKey(key string) (string, error) {
	var preUrl string
	err := controller.pool.Do(radix.Cmd(&preUrl, "GET", "url "+key))
	if err != nil {
		return "", err
	} else if preUrl == "" {
		return "", kernelErrors.NotFoundError
	}

	return preUrl, nil
}

func (controller *Redis) GetNewUniqueKey() (string, error) {
	var counter int
	err := controller.pool.Do(radix.Cmd(&counter, "INCR", "counter"))
	return utils.NumberToLexString(counter), err
}

func (controller *Redis) GenericKeySupport() bool {
	return true
}

func (controller *Redis) GetName() string {
	return controller.name
}

func (controller *Redis) GetType() string {
	return "Database.Redis"
}
