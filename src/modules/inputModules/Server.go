package inputModules

import (
	"context"
	"encoding/json"
	"github.com/labstack/echo/v4"
	"goshort/src/kernel"
	"goshort/src/types"
	kernelErrors "goshort/src/types/errors"
	"net/http"
	"strconv"
	"sync"
	"time"
)

type Server struct {
	types.ModuleBase
	echo         *echo.Echo
	ip           string
	port         string
	moduleName   string
	Kernel       *kernel.Kernel
	nativeClosed bool
	token        string
}

func CreateServer(kernel *kernel.Kernel) types.InputInterface {
	return &Server{Kernel: kernel}
}

// @Summary Create url by sent data
// @Tags Url
// @ID postUrl
// @Description Use json to generate url. If you want to create autogenerated key, leave key field empty.
// @Accept  json
// @Produce json
// @Param url body types.Url true "This is body string param"
// @Success 201 {object} types.Url "Successfully created"
// @Failure 400 "Bad input data"
// @Failure 409 "Already exists"
// @Router /urls/ [post]
func (server *Server) urlsPostHandler(c echo.Context) error {
	var newUrl types.Url
	if err := json.NewDecoder(c.Request().Body).Decode(&newUrl); err != nil {
		return c.NoContent(http.StatusBadRequest)
	}

	postedUrl, err := server.Kernel.Database.Post(newUrl)
	if err != nil {
		return err
	}

	return c.JSON(http.StatusCreated, postedUrl)
}

// @Summary Edit url by sent data
// @Tags Url
// @ID patchUrl
// @Accept  json
// @Produce json
// @Param key path string true "Url key"
// @Param url body types.Url true "This is body string param"
// @Success 200 {object} types.Url
// @Failure 400 "Bad input data"
// @Failure 404 "No such url"
// @Router /urls/{key} [patch]
func (server *Server) urlsPatchRequest(c echo.Context) error {
	id := c.Param("id")
	url_, err := server.Kernel.Database.Get(id)
	if err != nil {
		return err
	}

	var newUrl types.Url
	if err := json.NewDecoder(c.Request().Body).Decode(&newUrl); err != nil {
		return err
	}

	url_.Url = newUrl.Url
	if err := server.Kernel.Database.Patch(url_); err != nil {
		return err
	}

	return c.JSON(http.StatusOK, url_)
}

// @Summary Get url by key
// @Tags Url
// @ID getUrl
// @Produce json
// @Param key path string true "Url key"
// @Success 200 {object} types.Url
// @Failure 400 "Bad input data"
// @Failure 404 "No such url"
// @Router /urls/{key} [get]
func (server *Server) urlsGetHandler(c echo.Context) error {
	id := c.Param("id")
	url_, err := server.Kernel.Database.Get(id)
	if err != nil {
		return err
	}

	return c.JSON(http.StatusOK, url_)
}

// @Summary Delete url by key
// @Tags Url
// @ID deleteUrl
// @Param key path string true "Url key"
// @Router /urls/{key} [delete]
// @Failure 204 "Successfully deleted"
// @Failure 400 "Bad input data"
// @Failure 404 "No such url"
func (server *Server) urlsDeleteRequest(c echo.Context) error {
	id := c.Param("id")
	err := server.Kernel.Database.Delete(id)
	if err != nil {
		return err
	}

	return c.NoContent(http.StatusNoContent)
}

func (server *Server) registerUrlsHandlers(g *echo.Group) {
	g.POST("/urls/", server.urlsPostHandler)
	g.GET("/urls/:id/", server.urlsGetHandler)
	g.PATCH("/urls/:id/", server.urlsPatchRequest)
	g.PUT("/urls/:id/", server.urlsPatchRequest)
	g.DELETE("/urls/:id/", server.urlsDeleteRequest)
}

func (server *Server) redirect(c echo.Context) error {
	id := c.Param("id")
	urlVal, _ := server.Kernel.Database.Get(id)
	if urlVal.Url == "" {
		return c.HTML(http.StatusNotFound, "<h1>Not found.</h1>")
	}
	return c.Redirect(urlVal.Code, urlVal.Url)
}

func (server *Server) mainPage(c echo.Context) error {
	return c.HTML(http.StatusNotFound, "<h1>Main page</h1>")
}

type ServerLog struct {
	ClientIp         string
	Status           int
	Endpoint         string
	Method           string
	ServerLogIsError bool
	Error            types.Log
}

func (l *ServerLog) ToMap() map[string]interface{} {
	data := make(map[string]interface{})
	data["name"] = "Input.Server.ConnectionLog"
	data["type"] = "log"
	data["endpoint"] = l.Endpoint
	data["clientIp"] = l.ClientIp
	data["method"] = l.Method
	data["status"] = l.Status
	if l.Error != nil {
		data["type"] = "error"
		data["error"] = l.Error
	}
	return data
}

func (l *ServerLog) IsError() bool {
	return l.ServerLogIsError
}

func (server *Server) authMiddleware(next echo.HandlerFunc) echo.HandlerFunc {
	return func(c echo.Context) error {
		if server.token != "" && c.Request().Header.Get("Authorization") != "Bearer "+server.token {
			return c.NoContent(http.StatusUnauthorized)
		}

		return next(c)
	}
}

func (server *Server) mainLoggingMiddleware(next echo.HandlerFunc) echo.HandlerFunc {
	return func(c echo.Context) error {
		var err types.Log
		err = nil
		if err2 := next(c); err2 != nil {
			//httpErr, ok := err2.(echo.HTTPError)
			err = &kernelErrors.SimpleErrorWrapper{Err: err2}
		}

		le := &ServerLog{
			ClientIp: c.RealIP(),
			Status:   c.Response().Status,
			Endpoint: c.Request().RequestURI,
			Method:   c.Request().Method,
			Error:    err,
		}

		_ = server.Kernel.Logger.Send(le)
		return nil
	}
}

func (server *Server) errorManageMiddleware(next echo.HandlerFunc) echo.HandlerFunc {
	return func(c echo.Context) error {
		err := next(c)
		if err == kernelErrors.NotFoundError {
			return c.NoContent(http.StatusNotFound)
		} else if err == kernelErrors.AlreadyExistsError {
			return c.NoContent(http.StatusConflict)
		} else if _, ok := err.(*json.SyntaxError); ok == true {
			return c.NoContent(http.StatusBadRequest)
		}
		return err
	}
}

func (server *Server) Init(config map[string]interface{}) error {
	if err := server.ModuleBase.Init(config); err != nil {
		return err
	}

	server.echo = echo.New()
	server.moduleName = config["name"].(string)
	server.ip = config["ip"].(string)
	server.port = strconv.Itoa(config["port"].(int))
	server.token, _ = config["token"].(string)
	server.echo.HideBanner = true
	server.echo.HidePort = true

	api := server.echo.Group("api")
	api.Use(server.authMiddleware)
	api.POST("/urls/", server.urlsPostHandler)
	api.GET("/urls/:id/", server.urlsGetHandler)
	api.PATCH("/urls/:id/", server.urlsPatchRequest)
	api.PUT("/urls/:id/", server.urlsPatchRequest)
	api.DELETE("/urls/:id/", server.urlsDeleteRequest)

	server.echo.GET("/:id", server.redirect)
	server.echo.GET("/", server.mainPage)
	server.echo.Use(server.mainLoggingMiddleware)
	server.echo.Use(server.errorManageMiddleware)
	return nil
}

func (server *Server) Run(wg *sync.WaitGroup) error {
	go func() {
		defer wg.Done()
		server.Kernel.SetModuleRunState(server)
		defer server.Kernel.SetModuleStopState(server)
		err := server.echo.Start(server.ip + ":" + server.port)
		if err != nil {
			if !(err == http.ErrServerClosed && server.nativeClosed) {
				_ = server.Kernel.Logger.SendError(err)
			}
		}
	}()
	return nil
}

func (server *Server) Stop() error {
	server.nativeClosed = true
	ctx, cancel := context.WithTimeout(context.Background(), time.Second)
	defer cancel()
	err := server.echo.Shutdown(ctx)
	return err
}

func (server *Server) GetName() string {
	return server.moduleName
}

func (server *Server) GetType() string {
	return "Input.Server"
}
