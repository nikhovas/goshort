package dbModules

import (
	"errors"
	"github.com/mediocregopher/radix/v3"
	"goshort/kernel"
	kernelErrors "goshort/kernel/errors"
	"goshort/kernel/utils"
	"time"
)

type Redis struct {
	pool     *radix.Pool
	ip       string
	poolSize int
	name     string
	Kernel   *kernel.Kernel
}

func (controller *Redis) Init(config map[string]interface{}) error {
	controller.pool = nil
	controller.ip = config["ip"].(string)
	controller.poolSize = config["pool_size"].(int)
	return nil
}

func (controller *Redis) Run() error {
	var err error
	controller.pool, err = radix.NewPool("tcp", controller.ip, controller.poolSize)
	return err
}

func (controller *Redis) Get(key string) (kernel.Url, error) {
	var preUrl string
	if err := controller.pool.Do(radix.Cmd(&preUrl, "GET", "url "+key)); err != nil {
		return kernel.Url{}, err
	}
	if preUrl == "" {
		return kernel.Url{}, kernelErrors.UrlNotFoundError
	}

	urlData, err := kernel.FromString(preUrl)
	if err != nil {
		return kernel.Url{}, nil
	}
	urlData.Key = key

	return urlData, nil
}

func (controller *Redis) Post(newUrl kernel.Url) (kernel.Url, error) {
	var p string
	if newUrl.Autogenerated {
		added := false
		for !added {
			potentialKey, err := controller.GetPotentialKey(newUrl.Url)
			if err != nil && !errors.Is(err, kernelErrors.KeyNotFoundError) {
				return kernel.Url{}, err
			}

			if err == nil { // key is found
				potentialUrl, err := controller.Get(potentialKey)
				if err != nil && !errors.Is(err, kernelErrors.KeyNotFoundError) {
					return kernel.Url{}, err
				}
				if potentialUrl.Url == newUrl.Url {
					newUrl = potentialUrl
					added = true
				}
			} else { // key is free
				newUrl.Key, err = controller.GetNewUniqueKey()

				err = controller.pool.Do(radix.Cmd(&p, "SET", "url "+newUrl.Key, newUrl.ToString(), "NX"))
				// todo inspect
				if errors.Is(err, kernelErrors.ValueAlreadyExistsError) {
					added = false
				} else if err != nil {
					return kernel.Url{}, err
				} else {
					added = true
				}

				err = controller.pool.Do(radix.Cmd(nil, "SET", "autogen "+newUrl.Url, newUrl.Key))
				if err != nil {
					return kernel.Url{}, nil
				}
			}
			time.Sleep(time.Second)
		}
	} else {
		err := controller.pool.Do(radix.Cmd(&p, "SET", "url "+newUrl.Key, newUrl.ToString(), "NX"))
		if err != nil {
			return kernel.Url{}, err
		}
	}

	return newUrl, controller.pool.Do(radix.Cmd(nil, "SAVE"))
}

func (controller *Redis) Patch(patchUrl kernel.Url) error {
	if patchUrl.Autogenerated {
		p := radix.Pipeline(
			radix.Cmd(nil, "SET", "url "+patchUrl.Key, patchUrl.ToString()),
			radix.Cmd(nil, "SET", "autogen "+patchUrl.Url, patchUrl.Key),
		)

		if err := controller.pool.Do(p); err != nil {
			panic(err)
		}
	} else {
		err := controller.pool.Do(
			radix.Cmd(nil, "SET", "url "+patchUrl.Key, patchUrl.ToString()))
		if err != nil {
			return err
		}
	}

	return controller.pool.Do(radix.Cmd(nil, "SAVE"))
}

func (controller *Redis) Delete(url_ kernel.Url) error {
	if url_.Autogenerated {
		p := radix.Pipeline(
			radix.Cmd(nil, "DEL", "url "+url_.Key, url_.ToString()),
			radix.Cmd(nil, "DEL", "autogen "+url_.Url, url_.Key),
		)

		if err := controller.pool.Do(p); err != nil {
			return err
		}
	} else {
		err := controller.pool.Do(
			radix.Cmd(nil, "DEL", "url "+url_.Key, url_.ToString()))
		if err != nil {
			return err
		}
	}
	return controller.pool.Do(radix.Cmd(nil, "SAVE"))
}

func (controller *Redis) GetPotentialKey(key string) (string, error) {
	var preUrl string
	err := controller.pool.Do(radix.Cmd(&preUrl, "GET", "url "+key))
	if err != nil {
		return "", err
	} else if preUrl == "" {
		return "", kernelErrors.KeyNotFoundError
	}

	return preUrl, nil
}

func (controller *Redis) GetNewUniqueKey() (string, error) {
	var counter int
	err := controller.pool.Do(radix.Cmd(&counter, "INCR", "counter"))
	return utils.NumberToLexString(counter), err
}

func (controller *Redis) GenericKeySupport() bool {
	return true
}

func (controller *Redis) GetName() string {
	return controller.name
}

func (controller *Redis) GetType() string {
	return "Redis"
}
