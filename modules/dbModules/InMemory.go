package dbModules

import (
	"errors"
	"goshort/kernel"
	"goshort/kernel/utils"
	"goshort/types"
	kernelErrors "goshort/types/errors"
	"sync"
	"sync/atomic"
	"time"
)

type InMemory struct {
	types.ModuleBase
	MaxElements         int
	Kernel              *kernel.Kernel
	Name                string
	dataStorage         sync.Map
	inverseStorage      sync.Map
	currentCount        uint64
	currentGenericCount uint64
	mutex               sync.RWMutex
}

func CreateInMemory(kernel *kernel.Kernel) types.UrlControllerInterface {
	return &InMemory{Kernel: kernel}
}

func (controller *InMemory) Init(config map[string]interface{}) error {
	if err := controller.ModuleBase.Init(config); err != nil {
		return err
	}
	controller.MaxElements = config["max_elements"].(int)
	controller.Name = config["name"].(string)
	return nil
}

func (controller *InMemory) Run() error {
	defer controller.Kernel.OperationDone()
	return nil
}

func (controller *InMemory) Stop() error {
	return nil
}

func (controller *InMemory) Get(key string) (types.Url, error) {
	controller.mutex.RLock()
	defer controller.mutex.RUnlock()

	var url types.Url
	v, ok := controller.dataStorage.Load(key)
	if !ok {
		return url, kernelErrors.NotFoundError
	}

	url, ok = v.(types.Url)
	return url, nil
}

func (controller *InMemory) Post(newUrl types.Url) (types.Url, error) {
	controller.mutex.RLock()
	defer controller.mutex.RUnlock()

	if newUrl.Autogenerated {
		added := false
		for !added {
			v, ok := controller.inverseStorage.Load(newUrl.Url)
			if ok {
				potentialKey := v.(string)
				potentialUrl, err := controller.Get(potentialKey)
				if err != nil && !errors.Is(err, kernelErrors.NotFoundError) {
					return types.Url{}, err
				}
				if potentialUrl.Url == newUrl.Url {
					newUrl = potentialUrl
					added = true
				}
			} else { // key is free
				newUrl.Key = controller.GetNewUniqueKey()
				_, loaded := controller.dataStorage.LoadOrStore(newUrl.Key, newUrl)
				if !loaded {
					added = true
				} else {
					added = false
				}
			}
			time.Sleep(time.Second)
		}

		controller.inverseStorage.Store(newUrl.Url, newUrl.Key)
	} else {
		controller.dataStorage.Store(newUrl.Key, newUrl)
	}

	return newUrl, nil
}

func (controller *InMemory) Patch(patchUrl types.Url) error {
	if patchUrl.Autogenerated {
		controller.mutex.Lock()
		defer controller.mutex.Unlock()

		controller.dataStorage.Store(patchUrl.Key, patchUrl)
		controller.inverseStorage.Store(patchUrl.Url, patchUrl.Key)
	} else {
		controller.mutex.RLock()
		controller.mutex.RUnlock()

		controller.dataStorage.Store(patchUrl.Key, patchUrl)
	}

	return nil
}

func (controller *InMemory) Delete(url_ types.Url) error {
	if url_.Autogenerated {
		controller.mutex.Lock()
		defer controller.mutex.Unlock()

		controller.dataStorage.Delete(url_.Key)
		controller.inverseStorage.Delete(url_.Url)
	} else {
		controller.mutex.RLock()
		controller.mutex.RUnlock()

		controller.dataStorage.Delete(url_.Key)
	}

	return nil
}

func (controller *InMemory) GenericKeySupport() bool {
	return true
}

func (controller *InMemory) GetNewUniqueKey() string {
	counter := atomic.AddUint64(&controller.currentGenericCount, 1)
	return utils.NumberToLexString(int(counter))
}

func (controller *InMemory) GetName() string {
	return controller.Name
}

func (controller *InMemory) GetType() string {
	return "InMemory"
}

func (controller *InMemory) TryReconnect() error {
	return nil
}
